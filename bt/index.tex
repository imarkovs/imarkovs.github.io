% Created 2026-01-23 Fri 16:30
% Intended LaTeX compiler: pdflatex
\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\input{/home/im/texinputs/mystyle-org.tex}\usepackage[final]{pdfpages}
\newcommand{\quotebib}[1]{\begin{quote}\small\bibentry{#1}\end{quote}}
\topmargin=-1.5cm  \oddsidemargin=-1cm \evensidemargin=-1cm
\textheight=25cm   \textwidth=18cm
\author{Ivan Markovsky}
\date{}
\title{The Behavioral Toolbox}
\begin{document}

\maketitle
The Behavioral Toolbox is a collection of Matlab functions for analysis and design of dynamical systems using the behavioral approach to systems theory and control. It implements newly emerged nonparameteric data-driven methods for linear time-invariant systems. In order to install it, download and unpack the \href{./bt.tar}{archive file of the functions}. A tutorial for its usage is given in Section 3 of the \href{./bt.pdf}{documentation}. In order to cite it, please use:
\begin{quote}
I. Markovsky. \href{https://imarkovs.github.io/publications/bt-l4dc.pdf}{The behavioral toolbox}. In Proc. of Machine Learning Research, volume 242, pages 130--141, 2024.
\end{quote}
\begin{quote}
\begin{verbatim}
@InProceedings{bt-l4dc,
  Author =    {I. Markovsky},
  Title =     {The Behavioral Toolbox},
  booktitle = {Proc. of Machine Learning Research},
  volume =    {242},
  pages =     {130--141},
  Year =      {2024}
}
\end{verbatim}
\end{quote}

\section*{Examples}
\label{sec:orge9bb74f}

In the examples shown below, a trajectory of a discrete-time linear time-invariant system---\emph{the data}---is given and the goal is to find some property of the data-generating system or solve a problem with the data-generating. It is assumed that the data fully specifies the system (see Section 3.7 in the \href{./bt.pdf}{documentation}).

\subsection*{Finding the number of inputs}
\label{sec:org06cd12e}
The data is a vector time series containing the observed variables of the system. Since these variables are not partitioned into inputs and outputs, which variables are inputs is not known. Also, how many variables are inputs is not known. It is possible however to fining the number of inputs from the given data. The function of the toolbox that does this is \texttt{w2c}. In addition to finding the number of inputs \(m\), it finds also the order \(n\) and the lag \(\ell\) of the underlying data-generating system. 

Here is an example:
\begin{itemize}
\item specify the simulation parameters---number of variables \texttt{q}, number of inputs \texttt{m}, lag \texttt{ell}, order \texttt{n}, and number of data samples \texttt{Td}
\end{itemize}
\begin{minted}[]{matlab}
q = 3; m = 1; ell = 2; n = 3; Td = 100; 
\end{minted}
\begin{itemize}
\item generate a random linear time-invariant system with the specified parameters
\end{itemize}
\begin{minted}[]{matlab}
B = randB(q, [m, ell, n]); 
\end{minted}
\begin{itemize}
\item generate a random trajectory of the system with the specified number of samples
\end{itemize}
\begin{minted}[]{matlab}
wd = B2w(B, Td); 
\end{minted}
\begin{itemize}
\item call the \texttt{w2c} function
\end{itemize}
\begin{minted}[]{matlab}
[~, mh, ellh, nh] = w2c(wd);
\end{minted}
\begin{itemize}
\item check if the computed result is correct
\end{itemize}
\begin{minted}[]{matlab}
[m == mh, ell == ellh, n == nh] % -> [1 1 1]  
\end{minted}

\emph{But what about the assumption?} A ``sufficiently long'' random trajectory almost surely fully specifies the system. Quantifying what ``sufficiently long'' means, however, requires knowledge of \(m\) and \(n\). There is no way out of the dilemma, either we have to assume that the data fully specifies the system, or we have to know \(m\) and \(n\), in which case we can check the condition.

\emph{Exercise:} Change the simulation parameters and find out empirically when the data is ``sufficiently long''.

\subsection*{Finding an input/output partitioning of the variables}
\label{sec:org6067d52}

We've seen that we can find the number of inputs \(m\) from the data. Can we find also \emph{the} input variables \(u\)? No, in general, we can not do this because different sets of variables can act as inputs. The function of the toolbox that finds all possibilities of partitioning the variables into inputs and outputs is \texttt{BT2IO}. 

\texttt{BT2IO} (as well as other functions of the toolbox) takes as an input argument a matrix \(B_T\) that can be obtained from the data using \texttt{w2BT}. \(B_T\) defines a non-parametric representation of the finite-horizon behavior \(\mathcal{B}|_T\). The horizon \(T\) is a problem dependent. For \texttt{BT2IO} the required horizon is \(T = 2\ell+1\).

Continuing the example above, 
\begin{itemize}
\item first, we obtain the matrix \(B_T\):
\end{itemize}
\begin{minted}[]{matlab}
T = 2 * ell + 1; BT = w2BT(wd, T, [m ell n]);
\end{minted}
\begin{itemize}
\item then, we call \texttt{BT2IO}:
\end{itemize}
\begin{minted}[]{matlab}
IO = BT2IO(BT, q)
\end{minted}
Its output 
\begin{minted}[]{matlab}
IO =

     1     2     3
     1     3     2
     2     1     3
     2     3     1
     3     1     2
     3     2     1
\end{minted}
is a matrix, the rows of which indicate the possible input/output partitionings, e.g., 
\begin{minted}[]{matlab}
ud = wd(:, IO(1, 1:m)); yd = ud = wd(:, IO(:, m+1:end));
\end{minted}
is the first input/output partitioning.

\emph{Exercise:} In the example above, all partitionings of the variables are valid input/output partitionings. Create an example where this is not the case.

\subsection*{Distance of a signal to a system}
\label{sec:org0da7432}

A useful operation is computing distance between data and system. In particular, it allows us to check if a given signal is a valid trajectory of the system. In case it is not, the distance computation returns the best approximation of this signal by a trajectory of the system. This operation is called smoothing. 

The distance computation is implemented in the function \texttt{dist}. As a specification of the system, it accepts both \texttt{lti} object as well as (\(B_T\)), in which case the horizon \(T\) should be at least the length of the signal.

Continuing the example above, first, we generate a random trajectory and compute its distance to the system:
\begin{minted}[]{matlab}
T = 100; w0 = B2w(B, T); dist(w0, B) % -> 0
\end{minted}
Then, we add a perturbation and compute its distance to the system:
\begin{minted}[]{matlab}
w = w0 + randn(size(w0)); [d, wh] = dist(w, B);
\end{minted}
The distance of the best approximation to the original trajectory is smaller than the distance of the perturbed trajectory to the original trajectory:
\begin{minted}[]{matlab}
[norm(w0 - wh) norm(w0 - w)]
\end{minted}

\subsection*{Distance between systems}
\label{sec:org2db7394}

How to check if two systems are equal. For example, by construction the system
\begin{minted}[]{matlab}
Bp = ss2ss(B, rand(n));
\end{minted}
is equal to \texttt{B}, however, the Control Toolbox of matlab does not allow us to infer this by 
\begin{minted}[]{matlab}
B == Bp % -> Operator '==' is not supported for operands of type 'ss'.
\end{minted}
Instead, we can check the norm of difference:
\begin{minted}[]{matlab}
norm(Bp - B) % -> 0
\end{minted}
This, however, is restricted to stable systems only. 

The function \texttt{Bdist} of the toolbox computes distance between systems defined as the angle between the corresponding behaviors:
\begin{minted}[]{matlab}
Bdist(Bp, B) % -> 0
\end{minted}
This distance measure is not restricted to stable systems.

\subsection*{Distance of a signal to being a trajectory of a bounded complexity system}
\label{sec:org4c310dc}

In the previous sections we considered distance of a signal to a system and distance between systems. 
In this section, we consider another distance problem: the distance of a given signal to a system in a class of linear time-invariant systems with bounded complexity. 
This is actually a model identification problem. Zero distance means that there is an exact model of bounded complexity. Nonzero distance delivers as a by-product a system with bounded complexity that certifies the reported distance. Since the problem is non-convex there is no grantee that the obtained distance is globally minimal.
\end{document}
