#+TITLE: The Behavioral Toolbox
#+HTML_HEADER: <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}}); </script> <script type="text/javascript" src="/home/im/MathJax/MathJax.js?config=TeX-AMS_HTML-full"></script>
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="jemdoc.css" />
# #+HTML_MATHJAX: mathml:t path:"/home/im/MathJax/MathJax.js"

The Behavioral Toolbox is a collection of Matlab functions for analysis and design of dynamical systems using the behavioral approach to systems theory and control. It implements newly emerged nonparameteric data-driven methods for linear time-invariant systems. In order to install it, download and unpack the [[./bt.tar][archive file of the functions]]. A tutorial for its usage is given in Section 3 of the [[./bt.pdf][documentation]]. In order to cite it, please use:
#+begin_quote
I. Markovsky. [[https://imarkovs.github.io/publications/bt-l4dc.pdf][The behavioral toolbox]]. In Proc. of Machine Learning Research, volume 242, pages 130--141, 2024.
#+end_quote
#+begin_quote
#+begin_src 
@InProceedings{bt-l4dc,
  Author =    {I. Markovsky},
  Title =     {The Behavioral Toolbox},
  booktitle = {Proc. of Machine Learning Research},
  volume =    {242},
  pages =     {130--141},
  Year =      {2024}
}
#+end_src
#+end_quote

* Examples

In the examples shown below, a trajectory of a discrete-time linear time-invariant system---/the data/---is given and the goal is to find some property of the data-generating system or solve a problem with the data-generating. It is assumed that the data fully specifies the system (see Section 3.7 in the [[./bt.pdf][documentation]]).

** Finding the number of inputs
# Their importance is due to the fact that they determine the system's complexity: The more variables are inputs and the higher the order is, the more complex the system is. 

The data is a vector time series containing the observed variables of the system. Since these variables are not partitioned into inputs and outputs, which variables are inputs is not known. Also, how many variables are inputs is not known. It is possible however to fining the number of inputs from the given data. The function of the toolbox that does this is =w2c=. In addition to finding the number of inputs $m$, it finds also the order $n$ and the lag $\ell$ of the underlying data-generating system. 

Here is an example:
- specify the simulation parameters---number of variables =q=, number of inputs =m=, lag =ell=, order =n=, and number of data samples =Td=
#+BEGIN_SRC matlab :tangle examples.m
q = 3; m = 1; ell = 2; n = 3; Td = 100; 
#+END_SRC
- generate a random linear time-invariant system with the specified parameters
#+BEGIN_SRC matlab :tangle examples.m
B = randB(q, [m, ell, n]); 
#+END_SRC
- generate a random trajectory of the system with the specified number of samples
#+BEGIN_SRC matlab :tangle examples.m
wd = B2w(B, Td); 
#+END_SRC
- call the =w2c= function
#+BEGIN_SRC matlab :tangle examples.m
[~, mh, ellh, nh] = w2c(wd);
#+END_SRC
- check if the computed result is correct
#+BEGIN_SRC matlab :tangle examples.m
[m == mh, ell == ellh, n == nh] % -> [1 1 1]  
#+END_SRC

/But what about the assumption?/ A "sufficiently long" random trajectory almost surely fully specifies the system. Quantifying what "sufficiently long" means, however, requires knowledge of $m$ and $n$. There is no way out of the dilemma, either we have to assume that the data fully specifies the system, or we have to know $m$ and $n$, in which case we can check the condition.

/Exercise:/ Change the simulation parameters and find out empirically when the data is "sufficiently long".

** Finding an input/output partitioning of the variables

We've seen that we can find the number of inputs $m$ from the data. Can we find also /the/ input variables $u$? No, in general, we can not do this because different sets of variables can act as inputs. The function of the toolbox that finds all possibilities of partitioning the variables into inputs and outputs is =BT2IO=. 

=BT2IO= (as well as other functions of the toolbox) takes as an input argument a matrix $B_T$ that can be obtained from the data using =w2BT=. $B_T$ defines a non-parametric representation of the finite-horizon behavior $\mathcal{B}|_T$. The horizon $T$ is a problem dependent. For =BT2IO= the required horizon is $T = 2\ell+1$.

Continuing the example above, 
- first, we obtain the matrix $B_T$: 
#+begin_src matlab :tangle examples.m
T = 2 * ell + 1; BT = w2BT(wd, T, [m ell n]);
#+end_src
- then, we call =BT2IO=:
#+begin_src matlab :tangle examples.m
IO = BT2IO(BT, q)
#+end_src
Its output 
#+begin_src matlab
IO =

     1     2     3
     1     3     2
     2     1     3
     2     3     1
     3     1     2
     3     2     1
#+end_src
is a matrix, the rows of which indicate the possible input/output partitionings, e.g., 
#+begin_src matlab
ud = wd(:, IO(1, 1:m)); yd = ud = wd(:, IO(:, m+1:end));
#+end_src
is the first input/output partitioning.

/Exercise:/ In the example above, all partitionings of the variables are valid input/output partitionings. Create an example where this is not the case.

** Checking controllability                                             :NP:



** Distance of a signal to a system

A useful operation is computing distance between data and system. In particular, it allows us to check if a given signal is a valid trajectory of the system. In case it is not, the distance computation returns the best approximation of this signal by a trajectory of the system. This operation is called smoothing. 

The distance computation is implemented in the function =dist=. As a specification of the system, it accepts both =lti= object as well as ($B_T$), in which case the horizon $T$ should be at least the length of the signal.

Continuing the example above, first, we generate a random trajectory and compute its distance to the system:
#+begin_src matlab :tangle examples.m
T = 100; w0 = B2w(B, T); dist(w0, B) % -> 0
#+end_src
Then, we add a perturbation and compute its distance to the system:
#+begin_src matlab :tangle examples.m
w = w0 + randn(size(w0)); [d, wh] = dist(w, B);
#+end_src
The distance of the best approximation to the original trajectory is smaller than the distance of the perturbed trajectory to the original trajectory:
#+begin_src matlab :tangle examples.m
[norm(w0 - wh) norm(w0 - w)]
#+end_src

** Distance between systems

How to check if two systems are equal. For example, by construction the system
#+begin_src matlab
Bp = ss2ss(B, rand(n));
#+end_src
is equal to =B=, however, the Control Toolbox of matlab does not allow us to infer this by 
#+begin_src matlab
B == Bp % -> Operator '==' is not supported for operands of type 'ss'.
#+end_src
Instead, we can check the norm of difference:
#+begin_src matlab
norm(Bp - B) % -> 0
#+end_src
This, however, is restricted to stable systems only. 

The function =Bdist= of the toolbox computes distance between systems defined as the angle between the corresponding behaviors:
#+begin_src matlab
Bdist(Bp, B) % -> 0
#+end_src
This distance measure is not restricted to stable systems.

** Distance of a signal to being a trajectory of a bounded complexity system :NP:

In the previous sections we considered distance of a signal to a system and distance between systems. 
In this section, we consider another distance problem: the distance of a given signal to a system in a class of linear time-invariant systems with bounded complexity. 
This is actually a model identification problem. Zero distance means that there is an exact model of bounded complexity. Nonzero distance delivers as a by-product a system with bounded complexity that certifies the reported distance. Since the problem is non-convex there is no grantee that the obtained distance is globally minimal.

* Tutorial                                                               :NP:

In order to make the behavioral approach computationally feasible, we consider discrete-time linear time-invariant systems over a finite horizon. The system's behavior in this case is a finite-dimensional shift-invariant subspace. The methods developed in the toolbox use a basis for this subspace as a nonparametric representation of the system. Analysis, signal processing, and control methods take as an input a basis. Identification methods take as an input a trajectory of the system and construct from it the nonparametric representation. 

** Nonparameteric representation of the restricted behavior

This section introduces the functions of the toolbox for creating and using the nonparametric representation of the system. As an illustrating numerical examples, we create a random linear time-invariant system defined by an input/state/output representation---a Matlab's =ss= object =B=:  
#+begin_src matlab :exports none :tangle demo.m
%% Simulation parameters
#+end_src
#+begin_src matlab :tangle demo.m
m = 2; p = 1; q = m + p; n = 3; B = drss(n, p, m);
#+end_src
#+begin_src matlab :exports none :tangle demo.m
%% The restricted behavior
#+end_src
After choosing a horizon =T=, the construction of an orthonormal basis =BT= for the finite-horizon behavior from the input/state/output representation =B= of the system is done by the function =B2BT=:
#+begin_src matlab :tangle demo.m
T = 10; BT = B2BT(B, T); 
#+end_src

The function =B2BT= implements a data-driven approach. Instead of using the parameters of the state-space representation of the system, it computes a random trajectory (using =lsim=), forms a Hankel matrix (using the toolbox's function =hank=), and computes an orthonormal basis for its image (using the =svd=). Alternative functions to =B2BT= that implement the model-based approach are =ss2BT= and =R2BT=. As the names suggest, =ss2BT= uses a state-space representation, while =R2BT= uses a kernel representation to compute the basis.

In order to verify that the output =BT= of =B2BT= is correct, first, we verify that its dimension is correct:
#+begin_src matlab :tangle demo.m
check(size(BT, 2) == m * T + n) % -> PASS
#+end_src
The function =check= prints "PASS" if its argument is true and "FAIL" otherwise. 

Then, we check that a random trajectory of the system is in the image of =BT=. The function =B2w= selects a random trajectory of =B=. Its output is a $T\times q$ matrix, where $T$ is the number of samples and $q$ is the number of variables. Checking if $w$ is a trajectory is a common task and is implemented in a function =w_in_B=:
#+begin_src matlab :tangle demo.m
w = B2w(B, T); check(w_in_B(w, B)) % -> PASS
#+end_src
The columns of =BT= are finite trajectories of the system. The function =BT2W= extracts them into a cell array =W=:
#+begin_src matlab :tangle demo.m
W = BT2W(BT, q); check(all(w_in_B(W, B))) % -> PASS
#+end_src
The function =w_in_B= as well as many other functions of the toolbox allow specification of multiple trajectories by a cell array as well as a single trajectory.

A \(q\)-variate, \(T\)-samples long signal \(w := \big(w(1),\ldots,w(T)\big)\) is represented in the toolbox by: 
- $T\times q$ matrix =w=, where =w(t, :)= \(= w^\top(t)\) or
- $qT\times 1$ vector =w= with the stacked consecutive samples.
The matrix format has the advantage that the number of variables $q$ can be deduced from the size. However, it is incompatible with the data-driven representation, which uses the vector format. The conversion from the matrix to the vector format is done by =vec(w')=, where =vec= is column-wise vectorization, and the conversion from the vector to the matrix format is done by =reshape(w, q, T)'=. Functions accepting $B_T$ as an input require $q$ to be passed as an extra input argument.

When the $T\times q$ matrix representation is used, multiple trajectories are stored in a cell array with $N$ elements, the \(i\)th element of which is a $T_i\times q$ matrix representing the \(i\)th trajectory $w^i$.  
When the $Tq\times1$ vector representation is used and $T_1=\cdots=T_N=:T$, multiple trajectories are stored in a $qT\times N$ matrix, the \(i\)th column of which represents the \(i\)th trajectory $w^i$.  

The computation of a basis $B_T$ from a trajectory of the system requires finding the dimension of of the finite-horizon behavior $\mathcal{B}|_T$. \danger Under standard conditions on ${w_\text{d}}$ that are almost certainly satisfied for a sufficiently long random trajectory ${w_\text{d}}\in\mathcal{B}|_T$, 
\[
\dim\,\mathcal{B}|_T = \text{rank}\,\mathcal{H}_T({w_\text{d}}). 
\]
Thus, \(\dim\,\mathcal{B}|_T\) can be found by rank computation. A robust way of computing $\text{rank}\,\mathcal{H}_T({w_\text{d}})$ is thresholding the singular values of $\mathcal{H}_T({w_\text{d}})$. The functions of the toolbox that construct $B_T$ from data therefore have an optional threshold parameter =tol= with default value:
#+name: default-tol
#+begin_src matlab
if ~exist('tol', 'var') || isempty(tol), tol = 1e-8; end % <default-tol>
#+end_src
Alternatively, the user can specify the model's complexity, in which case the dimension is computed as $mT+n$.

** Input/output partitionings
#+begin_src matlab :exports none :tangle demo.m
%% Input/output partitionings
#+end_src

A partitioning of the variables $w(t)$ into inputs $u(t)$ and outputs $y(t)$ is defined by a permutation matrix $\Pi\in\mathbb{R}^{q\times q}$ as follows:
\[
w\mapsto(u,y): \ \begin{bmatrix} u\\y\end{bmatrix} := \Pi w \qquad\text{and}\qquad (u,y)\mapsto w: \ w = \Pi^\top \begin{bmatrix} u\\y\end{bmatrix}. 
\]
$\Pi w$ reorders the variables $w$, so that the first $m$ variables are the inputs and the remaining $p:=q-m$ variables are the outputs. The permutation matrix $\Pi$ is specified in the functions of the toolbox by a vector =io=, such that =w(io)= $\mapsto$ =[u; y]=. The restricted behavior with permuted variables is created with the function =BT2BT=:
#+begin_src matlab :tangle demo.m
io = flip(1:q); BTp = BT2BT(BT, q, io);
#+end_src
Indeed, the trajectory $w':=\Pi w$ with permuted variables belongs to the image of =BTp=: 
#+begin_src matlab :tangle demo.m
check(w_in_B(w(:, io), BTp)) % -> PASS
#+end_src
The function =BT2UYT= extracts from the basis of the restricted behavior $\mathcal{B}|_T$ its input and output components:
#+begin_src matlab :tangle demo.m
[UT, YT] = BT2UYT(BT, m, p);
#+end_src

=BT2UYT= and other functions of the toolbox that require an input/output partitioning but do not accept a specification for it assume $\Pi = I_q$:
#+name: default-io
#+begin_src matlab :comments noweb
if ~exist('io', 'var') || isempty(io), io = 1:q; end % <default-io>
#+end_src
For a general input/output partitioning, defined by =io=, call the functions with input =BT2BT(BT, q, io)= instead of =BT=.

The inverse transformation =UYT2BT= reconstructs $\mathcal{B}|_T$ from its input and output components:
#+begin_src matlab :tangle demo.m
check(norm(BT - UYT2BT(UT, YT, m, p)) == 0) % -> PASS
#+end_src

The number of inputs $m$ is uniquely defined by the behavior. However, an input/output partitioning of the variables is in general not unique. The currently available methods in the literature for finding an input/output partitioning of a system $\mathcal{B}$ are based on parametric representations of the system (e.g., the kernel representation). The toolbox implements a data-driven method for finding an input/output partitioning directly from the finite-horizon behavior $\mathcal{B}|_T$. The function =is_io= checks if a given partitioning of the variables is a possible input/output partitioning and the function =BT2IO= finds all possible input/output partitionings of the system. In order to test =is_io= and =BT2IO=, consider the following single-input single-output system 
#+begin_src matlab :tangle demo.m
Bp = ss(tf([0 1], [1 1], 1));
#+end_src
that has an input/output partitioning $w = \left[\begin{smallmatrix} u\\y \end{smallmatrix}\right]$ but not $w = \left[\begin{smallmatrix} y\\u \end{smallmatrix}\right]$.
#+begin_src matlab :tangle demo.m
BpT = B2BT(Bp, T);
check(is_io(BpT, 2, [1 2]) == true)  % -> PASS 
check(is_io(BpT, 2, [2 1]) == false) % -> PASS
check(all(BT2IO(BpT, 2) == [1 2]))   % -> PASS
#+end_src

** Subbehaviors
#+begin_src matlab :exports none :tangle demo.m
%% Subbehaviors
#+end_src

The following subbehaviors of \(\mathcal{B}\) are of special interest:
- $\mathcal{Y}_0$ --- /zero-input subbehavior/, i.e., the set of transient responses,
- $\mathcal{U}_0$ --- /zero-output subbehavior/, i.e., the set of inputs blocked by the system,
- $\mathcal{B}_0$          --- /zero initial conditions subbehavior/, i.e., the set of zero initial conditions trajectories, 
- $\mathcal{B}_\text{c}$   --- /controllable subbehavior/, i.e., the set of trajectories that are patchable with zero past trajectory, and
- $\mathcal{B}_\text{p}$   --- /periodic subbehavior/, i.e., the set of periodic trajectories.
Orthonormal bases for their restrictions to $[1,T]$ are computed from $\mathcal{B}|_T$ by the following functions:
#+begin_src matlab :tangle demo.m
Y0 = BT2Y0(BT, q);
U0 = BT2U0(BT, q);
B0 = BT2B0(BT, q);
BC = BT2BC(BT, q);
#+end_src

Let's verify that a free response of $\mathcal{B}$ is in the image of =Y0=:
#+begin_src matlab :tangle demo.m
y0 = initial(B, rand(n, 1), T-1); check(w_in_B(y0, Y0)) % -> PASS
#+end_src
Next, we verify that $w = \left[\begin{smallmatrix} u\\ 0 \end{smallmatrix}\right]$ with $u$ in the image of =U0= is a trajectory of the system:
#+begin_src matlab :tangle demo.m
u0 = reshape(U0 * rand(size(U0, 2), 1), m, T)';
w0 = [u0 zeros(T, p)]; check(w_in_B(w0, BT)) % -> PASS
#+end_src
Next, we verify that the initial conditions of a random trajectory in the zero initial conditions subbehavior are zero
#+begin_src matlab :tangle demo.m
T0 = size(B0, 1) / q;
w0 = reshape(B0 * rand(size(B0, 2), 1), q, T0)'; 
xini = w2xini(w0, B); check(norm(xini) < tol) % -> PASS
#+end_src

# TODO: test for =BP=

Using the zero initial conditions subbehavior $\mathcal{B}_0\subset\mathcal{B}|_T$, we can find the zero initial conditions input-to-output map \(H_T : u|_T \mapsto y|_T\). Let $B_0$ be the matrix of the basis vectors for $\mathcal{B}_0$ and let $U_0$, $Y_0$ be the submatrices of $B_0$ corresponding to the inputs and the outputs. Then, $H_T = Y_0 U_0^{-1}$. The method is implemented in the function =BT2HT=:
#+begin_src matlab :tangle demo.m
[HT, T] = BT2HT(BT, q);
#+end_src
The $pT\times mT$ matrix $H_T$ is the finite-horizon representation of the transfer function $H(z)$ of the system $\mathcal{B}$ corresponding to the input/output partitioning. In particular, it has lower-triangular block-Toeplitz structure:
#+begin_src matlab :tangle demo.m
check(norm(HT - convm(B, T)) < tol) % -> PASS
#+end_src

** Analysis
#+begin_src matlab :exports none :tangle demo.m
%% Analysis
#+end_src

In this section, we find properties of the system directly from its restricted behavior, rather than from parametric representations as done by classical analysis methods. The properties considered are: complexity, controllability, \(H_\infty\)-norm, and distance between systems. 

*** System's complexity

The complexity $\mathbf{c}(\mathcal{B})$ of a linear time-invariant system $\mathcal{B}$ is defined as the triple: number of inputs $\mathbf{m}(\mathcal{B})$, lag $\mathbf{\ell}(\mathcal{B})$, and order \(\mathbf{n}(\mathcal{B})\). Although in the classical setting the order $\mathbf{n}(\mathcal{B})$ is defined via a minimal state-space representation, it is a property of the system $\mathcal{B}$ and can be computed directly from the restricted behavior $\mathcal{B}|_T$ (provided $T\geq\mathbf{\ell}(\mathcal{B})+1$). Also, the number of inputs $\mathbf{m}(\mathcal{B})$ can be computed from $\mathcal{B}|_T$ without reference to a particular input/output representation. The method for finding $\mathbf{m}(\mathcal{B})$ and $\mathbf{n}(\mathcal{B})$ from $\mathcal{B}|_T$ is based on the theoretical dimension $mT+n$. Evaluating $\dim\,\mathcal{B}|_{t_i}$ for $t_1\neq t_2\geq\mathbf{\ell}(\mathcal{B})$, e.g., $t_1=T$ and $t_2=T-1$, we obtain the system of equations
\[\begin{bmatrix} T & 1\\ T-1 & 1 \end{bmatrix} \begin{bmatrix} m\\ n \end{bmatrix} = \begin{bmatrix} \dim\,\mathcal{B}|_T\\ \dim\,\mathcal{B}|_{T-1} \end{bmatrix},\]
from which $m=\mathbf{m}(\mathcal{B})$ and $n=\mathbf{n}(\mathcal{B})$ can be found. The resulting method is implemented in the function =BT2c=:
#+begin_src matlab :tangle demo.m
[ch, mh, ellh, nh] = BT2c(BT, q); check(all([mh nh] == [m n])) % -> PASS
#+end_src
A model-based method for computing the lag of the system is implemented in the function =lag=:
#+begin_src matlab :tangle demo.m
ell = lag(B); check(ellh == ell) % -> PASS
#+end_src
As discussed in the next section, the complexity connects nonparameteric and parametric representations and is a critical first step in finding a parametric representation of the system. 

=BT2c= finds $\dim\,\mathcal{B}|_{T-1}$ and $\dim\,\mathcal{B}|_{T}$ by rank computation, i.e., thresholding of the singular values using \danger a user defined threshold =tol=. 

*** Distance between systems

The function =Bdist= computes distance between systems. The distance is defined as the principal angle between the finite-horizon behaviors of the systems with default horizon $T=100$. Here is an example:
#+begin_src matlab :tangle demo.m
Bp = B; Bp.a = Bp.a + 0.01 * randn(n); d = Bdist(B, Bp);
#+end_src
The distance measure =Bdist= is used by the function =equal= for checking if two systems are equal:
#+begin_src matlab :tangle demo.m
Bp = ss2ss(B, rand(n)); check(equal(B, Bp)) % -> PASS
#+end_src

*** Controllability

The controllable subbehavior $\mathcal{B}_c\subset\mathcal{B}|_T$ for $T\geq\mathbf{\ell}(\mathcal{B})$ is \(mT+n\)-dimensional if and only if $\mathcal{B}$ is controllable. This leads to a data-driven controllability test that is implemented in the function =isunctr=:
#+begin_src matlab :tangle demo.m
Bp = ss([0.5 1; 0 0.25], [1; 0], [1 1], 1, -1); 
n_unctr = isunctr(Bp); check(n_unctr == 1)  % -> PASS
#+end_src
Moreover, $mT + n - \dim\,\mathcal{B}_c|_T$ is the number of uncontrollable modes of \(\mathcal{B}\). Based on $\mathcal{B}_c$, a quantitative test for controllability---a distance to uncontrollability---is implemented in the function =distunctr=. Here is an example:
#+begin_src matlab :tangle demo.m
Bp = ss([0.5 1; 0 0.25], [1; 1e-5], [1 1], 1, -1); 
d = distunctr(Bp); % -> 1e-7
#+end_src

# TODO: Add an example: The control toolbox's order returns the size of A, which is not the order of the system

*** \(H_\infty\)-norm

Using the zero initial conditions input-to-output map $H_T$ of $\mathcal{B}$ for a given input/output partitioning allows us to compute the finite-horizon \(H_\infty\)-norm of $\mathcal{B}$. The method is implemented in the function =BT2Hinf=:
#+begin_src matlab :tangle demo.m
[Hinf, ~, uinf] = BT2Hinf(BT, q); C = convm(B, T);
check(abs(Hinf - norm(C)) / norm(C) < tol) % -> PASS
#+end_src

** Parametric representations
#+begin_src matlab :exports none :tangle demo.m
%% Parametric representations
#+end_src

So far, the tutorial reviewed functions related to and based on the nonparametric representation of the restricted behavior \(\mathcal{B}|_T\). This section shows an application of the approach for computing parametric representations.

Computing a kernel representation from $\mathcal{B}|_T$ is essentially applying the =null= function on $B^\top_{\ell+1}$. The method is implemented in the functions =B2R= and =BT2R= (=B2R= constructs =BT= from =B= and calls =BT2R=):
#+begin_src matlab :tangle demo.m
R = B2R(B); R = BT2R(BT, q); 
#+end_src
The inverse operation---finding the restricted behavior from a kernel or a state-space representation---is done by the functions =R2BT= and =ss2BT=, which implement the model-based approach, i.e., they construct $B_T$ from the model parameters $R$ and $(A,B,C,D)$, respectively. 
#+begin_src matlab :tangle demo.m
BT_ = R2BT(B2R(B), q, T); check(equal(B, BT_)) % -> PASS
BT_ = ss2BT(B, T);        check(equal(B, BT_)) % -> PASS
#+end_src
The basis computed by =ss2BT= is not orthonormal. It consists of observability and convolution matrices.

Contrary to =BT2R= (which is essentially Matlab's =null= function), computing a state-space representation from the restricted behavior is nontrivial. Indeed, it requires to do 1) state construction and 2) detect a possible input/output partitioning of the variables. The data-driven approach for these operations is implemented in the function =BT2ss=:
#+begin_src matlab :tangle demo.m
check(equal(B, BT2ss(BT, q))) % -> PASS
#+end_src
Similarly, the transformation from a kernel representation to a state-space representation is nontrivial. A data-driven method for this operation is implemented in the function =R2ss=:
#+begin_src matlab :tangle demo.m
check(equal(B, R2ss(R, q))) % -> PASS
#+end_src

For multi-output systems, the function =B2R= computes a /nonminimal/ kernel representation. Computing a minimal kernel representation or converting a nonminimal kernel representation to a minimal one are also nontrivial operations. Data-driven methods for them are implemented in the functions =BT2Rmin= and =R2Rmin=:
#+begin_src matlab :tangle demo.m
Rmin = BT2Rmin(BT, q); check(equal(BT, R2BT(Rmin, q, T), q)) % -> PASS
Rmin = R2Rmin(R, q);   check(equal(BT, R2BT(Rmin, q, T), q)) % -> PASS
#+end_src

The dichotomy of parametric vs nonparametric representations is misleading---there is a range of nonminimal parametric representations that cover the gap between minimal parametric and nonparametric representations. The problem of detecting when a parametric representation is minimal is equivalent to the one of finding the model's complexity. It is also essential in the case of identification from noisy data where the key issue is the one of achieving an accuracy--complexity trade-off.

All functions of the toolbox computing model's complexity accept as an optional input argument a tolerance for thresholding the singular values. Alternatively, the user may specify the model's complexity =[m, ell, n]= by =ctol=. If =ctol= is a scalar, it is used as a threshold =tol= for rank estimation. Otherwise, =ctol= should be the vector of integers specifying the model's complexity. 

** Signal processing and open-loop control
#+begin_src matlab :exports none :tangle demo.m
%% Signal processing and open-loop control
#+end_src

This section collects operations on signals by a dynamical system. The operations implemented are: projection of a signal on a system, computing initial conditions for a signal, simulation, and inference of one variable from another. They are special cases of a signal processing problem, called /interpolation and approximation of trajectories/.

*** Projection

The basic operation of projection of a signal $w\in(\mathbb{R}^q)^T$ on the behavior $\mathcal{B}|_T$ of a system $\mathcal{B}\in\mathcal{L}^q$ is equivalent to computing the /distance from $w$ to $\mathcal{B}$/. The same operation is equivalent to (errors-in-variables) Kalman smoothing: the projection $\hat w$ is the /smoothed version/ of $w$. The problem is solved by the function =dist=:
#+begin_src matlab :tangle demo.m
[d, wh] = dist(w, B);
#+end_src
The distance =d= from $w$ to $\mathcal{B}|_T$ is zero if and only if $w\in\mathcal{B}|_T$, so that =dist= is a robust way of checking if $w$ is an exact trajectory of $\mathcal{B}$. (It is used in the implementation of =w_in_B=.) 

*** Initial conditions estimation

For ${w_\text{d}}\in\mathcal{B}|_T$, there is a corresponding initial conditions. 
If $\mathcal{B}$ is defined by an input/state/output representation, the initial conditions can be specified by the initial state $x_\text{ini} = x(1)$. The initial state $x_\text{ini}$ corresponding to a trajectory $w$ can be found with the function =w2xini=:
#+begin_src matlab :tangle demo.m
[xini, e] = w2xini(w, B); check(norm(w - B2w(B, T, xini, w(:, 1:m))) < tol)  % -> PASS
#+end_src
The output argument =e= is zero when $w\in\mathcal{B}|_T$ and nonzero otherwise.

The initial conditions can be specified in a representation free way by an initial trajectory $w_\text{ini}$ of length $T_{\text{ini}}\geq\mathbf{\ell}(\mathcal{B})$. An initial trajectory $w_\text{ini}$ of corresponding to a given trajectory $w$ can be computed by the function =w2wini=:
#+begin_src matlab :tangle demo.m
BT = B2BT(B, ell + size(w,1));
[wini, e] = w2wini(w, BT, ell); check(w_in_B([wini; w], B)) % -> PASS
#+end_src

*** Simulation

The classical simulation problem: given initial conditions and input, find the corresponding output is solved by =u2y=:
#+begin_src matlab :tangle demo.m
yf = u2y(BT, q, w(:, 1:m), wini); check(w(:, m+1:end) - yf) % -> PASS
#+end_src

As another example, next, we use =u2y= in order to find the first =Tf= samples of the impulse response of the system:
#+begin_src matlab :tangle demo.m
Tf = 3; u1 = [[1; zeros(q * Tf - 1, 1)] zeros(q * Tf, m - 1)];
h1 = u2y(BT, q, u1); h = lsim(B, u1); check(h1 - h < tol) % -> PASS
#+end_src

*** Observer

Consider a linear time-invariant system $\mathcal{B}\in\mathcal{L}^q$. The variables $w$ of $\mathcal{B}$ are partitioned into given/observed variables $w_{\text{g}}$ with dimension $q_{\text{g}}$ and missing/to-be-estimated variables $w_{\text{m}}$ with dimension $q_{\text{m}} = q - q_{\text{g}}$. Without loss of generality, we assume that $w = \left[\begin{smallmatrix} w_{\text{g}}\\ w_m \end{smallmatrix}\right]$. The problem considered is: Given a system $\mathcal{B}\in\mathcal{L}^q$ and observed part $w_{\text{g}}$ of a trajectory $w\in\mathcal{B}|_T$, find the missing part $w_{\text{m}}$ of $w$.

The solution is based on the finite-horizon nonparameteric representation of $\mathcal{B}$. Let $B_{\text{g}}$ be the submatrix of $B_T$ corresponding to $w_{\text{g}}$ and $B_{\text{m}}$ be the submatrix corresponding to $w_{\text{m}}$. Then, there is a $g$, such that 
\[w_{\text{g}} = B_{\text{g}} g \quad\text{and}\quad w_{\text{m}} = B_{\text{m}} g.\]
Solving for $g$ the first equation and substituting into the second one, we have the following estimate of $w_{\text{m}}$:
\[\hat w_{\text{m}} := B_{\text{m}} B_{\text{g}}^+ w_{\text{g}}.\]
It can be shown that, when $\text{rank}\,B_{\text{g}} = \mathbf{m}(\mathcal{B})T+\mathbf{n}(\mathcal{B})$, \(\hat w_{\text{m}}\) is exact, i.e., of $\hat w_{\text{m}}=w_{\text{m}}$. 

Special cases of the observer problem are estimation of the input given the output (which is also a system inversion problem) and estimation of a second input, e.g., disturbance, given the input and the output. 

The solution of the observer problem is implemented in the function =wgiven2wmissing=. Here is an example verifying the method for disturbance estimation:
#+begin_src matlab :tangle demo.m
qg = 2; qm = 2; q = qm + qg; m = 1; p = q - m; n = 5; B = drss(n, p, m);
T = 20; w = B2w(B, T); wg = w(:, 1:qg); wm = w(:, qg+1:q);
wmh = wgiven2wmissing(wg, B); check(norm(wm - wmh) / norm(wm) < tol) % -> PASS
#+end_src

*** Open-loop control

The control problem considered is open-loop linear quadratic tracking: Given a system $\mathcal{B}\in\mathcal{L}^q$, to-be-tracked trajectory $w_\text{r}\in(\mathbb{R}^q)^{T_\text{r}}$, and tracking criterion 
\(\|e\|_v := \| v \otimes e \|,\)
where $v\in(\mathbb{R}_+^q)^{T_\text{r}}$ and $\otimes$ is the element product, 
\[
\text{minimize} \quad \text{over $\hat w\in(\mathbb{R}^q)^{T_\text{r}}$} \quad \text{norm}{w_\text{r} - \hat w}_v \quad\text{subject to}\quad \hat w \in \mathcal{B}|_{T_\text{r}}.
\]

A variation of the problem is to specify initial and final conditions for the control trajectory $\hat w$ via "past" and "future" trajectories $w_{\text{p}}\in(\mathbb{R}^q)^{T_{\text{p}}}$ and $w_\text{f}\in(\mathbb{R}^q)^{T_\text{f}}$:
\[
\text{minimize} \quad \text{over $\hat w\in(\mathbb{R}^q)^{T_\text{r}}$} \quad \text{norm}{w_\text{r} - \hat w}_v 
\quad\text{subject to}\quad 
w_{\text{p}} \wedge \hat w \wedge w_\text{f} \in \mathcal{B}|_{T_{\text{p}}+T_\text{r}+T_\text{f}}. 
\]
This allows us to solve optimal state transfer problems, i.e., find a trajectory of the system that achieves optimal transition from the given initial state to the given final state. The solution exists for any initial and final states if and only if the system $\mathcal{B}$ is controllable and the state transfer is at least \(\mathbf{\ell}(\mathcal{B})\)-samples long.

The function in the toolbox solving the open-loop linear quadratic tracking control problem is 
#+begin_src matlab
wh = lqctr(B, wr, v, wp, wf);
#+end_src
The input parameters =v=, =wp=, and =wf= are optional. The default value of =v= is =ones(Tr, q)=, i.e., uniform weights for all variables and all moments of time. If =wp= and/or =wf= is not specified, then the corresponding constraints are dropped, i.e., the corresponding initial or final condition is free.

Here is an example of linear quadratic tracking with free initial and final condition:
#+begin_src matlab :tangle demo.m
m = 1; p = 1; n = 3; q = m + p; B = drss(n, p, m); 
Tr = 10; wr = [zeros(Tr, m) ones(Tr, p)]; ell = lag(B);
v = [1e-2 * ones(Tr, m), ones(Tr, p)]; wh = lqctr(B, wr, v);
#+end_src
# plot(wr(:, 2), 'r:'), hold on, plot(wh(:, 2), 'b--')

In order to solve the optimal state transfer problem with specified initial and final states, first we check controllability of the system. The solution is verified by showing that $w_{\text{p}}{w_\text{d}}edge \hat w{w_\text{d}}edge w_\text{f} \in \mathcal{B}|_{T_{\text{p}}+T_\text{r}+T_\text{f}}$.
#+begin_src matlab :tangle demo.m
if ~isunctr(B)
  Tr = ell; wr = zeros(Tr, q);
  wp = B2w(B, ell); wf = zeros(ell, q); 
  wh = lqctr(B, wr, [], wp, wf);
  check(w_in_B([wp; wh; wf], B))
end
#+end_src
# plot(wr(:, 2), 'r:'), hold on, plot(wh(:, 2), 'b--')

*** Control as interconnection

In the following example the plant $\mathcal{B}$ is a \(4\)th order single-input single-output system, defined by the transfer function
\[H(z) =  \frac{0.2826z + 0.5067z^2}{1 - 1.4183z + 1.5894z^2 -1.3161z^3 + 0.8864z^4}.\]
#+begin_src matlab
Q = [0 0 0 0.28261 0.50666]; P = [1 -1.41833 1.58939 -1.31608 0.88642];
B = ss(tf(Q, P, -1)); 
#+end_src
The controller \(\mathcal{B}_\text{c}\) is obtained with the function =h2syn= from the Robust Control Toolbox of Matlab
#+begin_src matlab
Bc = h2syn(B, 1, 1); 
#+end_src
It leads to the closed-loop system $\mathcal{B}_\text{cl}$
#+begin_src matlab
B_ = ss(B.a, B.b, [B.c; B.c], [B.d; B.d], 1); Bcl = lft(B_, Bc); 
#+end_src

The closed-loop system $\mathcal{B}_\text{cl}$ can be obtained alternatively by projecting on the \(y\)-variable the interconnection of the plant $\mathcal{B}$ and the control $\mathcal{B}_\text{c}$ with flipped inputs and outputs:
\[
\mathcal{B}_\text{cl} = \Pi_y \big( \mathcal{B} \cap \left[\begin{smallmatrix} 0&1\\ 1&0 \end{smallmatrix}\right] \mathcal{B}_\text{c} \big).
\]
#+begin_src matlab
T = 10; BT = B2BT(B, T); BcT = B2BT(Bc, T); 
Bcl_wT = BTintersect(BT, BT2BT(BcT, q, [2 1])); 
[Bcl_uT, Bcl_yT] = BT2UYT(Bcl_wT, 1, 1); 
equal(Bcl, Bcl_yT, q) % -> 1
#+end_src

# BcT = BT2BT(BT, q, [2 1]); 

** Identification
#+begin_src matlab :exports none :tangle demo.m
%% Identification
#+end_src

The functions presented in the previous sections of the tutorial use the nonparameteric representation of a linear time-invariant system $\mathcal{B}\in\mathcal{L}_c^q$. In this section, the system $\mathcal{B}$ is implicitly specified by a trajectory $w_{\text{d}}\in\mathcal{B}|_{T_{text{d}}}$
#+begin_src matlab :tangle demo.m
Td = 100; wd = B2w(B, Td); 
#+end_src
A necessary and sufficient condition for ${w_\text{d}}$ to define $\mathcal{B}\in\mathcal{L}^q_c$ is the /identifiability condition/:
\]
\text{rank} \, \mathcal{H}_{\mathbf{\ell}(\mathcal{B})+1}({w_\text{d}}) = \mathbf{m}(\mathcal{B})\big(\mathbf{\ell}(\mathcal{B})+1\big) + \mathbf{n}(\mathcal{B}).
\]
This is a /generalized persistency of excitation/ condition on the data ${w_\text{d}}$ and requires prior knowledge of the complexity $\mathbf{c}(\mathcal{B})$ of the data-generating system $\mathcal{B}$. 

When the GPE condition is satisfied, $\mathcal{B}$ can be recovered from the data ${w_\text{d}}$. This is done by finding the /most powerful unfalsified model/ $\mathcal{B}_\text{mpum}({w_\text{d}})$ for ${w_\text{d}}$. $\mathcal{B}_\text{mpum}({w_\text{d}})$ is the least complicated exact model for ${w_\text{d}}$ in the class of linear time-invariant systems $\mathcal{L}^q$. Note that $\mathcal{B}_\text{mpum}({w_\text{d}})$ is well defined (i.e., it exists and is unique) for any ${w_\text{d}}\in(\mathbb{R}^q)^T_{text{d}}$, independently of whether or not the GPE condition holds. Also, finding $\mathcal{B}_\text{mpum}({w_\text{d}})$ from ${w_\text{d}}$ does not require priori knowledge of $\mathbf{c}(\mathcal{B})$: $\mathcal{B}_\text{mpum}({w_\text{d}})$ is a computational construct that has theoretical guarantees to recover the data-generating system under the GPE condition. 

For $T\geq\mathbf{\ell}(\mathcal{B})$, under the stronger generalized persistency of excitation condition 
\]
\text{rank} \, \mathcal{H}_{T}({w_\text{d}}) = \mathbf{m}(\mathcal{B})T + \mathbf{n}(\mathcal{B}),
\]
the data-driven representation holds. A necessary condition for the GPE condition is that the length $T_{\text{d}}$ of ${w_\text{d}}$ must satisfy the lower bound
\]
T_{\text{d}} \geq T_{\min} := (m+1)T+n-1,
\]
#+name: define-Tmin
#+begin_src matlab :tangle no
Tmin = @(T) (m + 1) * T + n - 1; %% <define-Tmin>
#+end_src
Thus, =Tmin= quantifies the statement "${w_\text{d}}$ is long enough for recovering the data-generating system".

An analog of =BT2c= for complexity computation from data ${w_\text{d}}$ is =c_mpum=, which computes $\mathbf{c}\big(\mathcal{B}_\text{mpum}({w_\text{d}})\big)$ without explicitly identifying $\mathcal{B}_\text{mpum}({w_\text{d}})$:
#+begin_src matlab :tangle demo.m
ch = c_mpum(wd); check(all(ch == [m, lag(B), n])) % -> PASS
#+end_src
The function =w2BT= computes a basis $B_T$ for $\mathcal{B}_\text{mpum}({w_\text{d}})|_T$ from data ${w_\text{d}}$ 
#+begin_src matlab :tangle demo.m
BhT = w2BT(wd, T);
#+end_src
Once $\hat B_T$ is obtained from ${w_\text{d}}$, the non-parametric analysis functions from the previous sections can be used. 

The second parameter of =w2BT= allows specification of an upper bound =[m, ell, n]= on the model's complexity, in which case unstructured low-rank approximation is used to enforce the bound. Alternatively, the second parameter of =w2BT= can be a tolerance =tol= for the estimation of the complexity by singular values thresholding. Unlike the function =slra=, which imposes both rank and structure constraints, =w2BT= doesn't impose shift-invariance structure on =BT=.

=c_mpum= and =w2BT= detect, respectively, $\mathbf{c}\big(\mathcal{B}_\text{mpum}({w_\text{d}})\big)$ and $\dim\,\mathcal{B}_\text{mpum}({w_\text{d}})$ from the data ${w_\text{d}}$ by rank computation with a user defined tolerance. \danger Alternatively, the user may specify directly a complexity bound. When the complexity is wrongly estimated or misspecified, there may be no $\hat{\mathcal{B}}\in\mathcal{L}^q_{(m,\ell,n)}$ that corresponds to $\text{image}\, B_T$. 

The following functions compute parametric representations of $\mathcal{B}_\text{mpum}({w_\text{d}})$ and thus by construction impose both the bounded complexity and LTI structure. A kernel representation of $\mathcal{B}_\text{mpum}({w_\text{d}})$ is obtained by the function =w2R=:
#+begin_src matlab :tangle demo.m
R = w2R(wd); check(w_in_B(wd, R2BT(R, q, Td))) % -> PASS
#+end_src
and a state-space representation by the function =w2ss=:
#+begin_src matlab :tangle demo.m
Bh = w2ss(wd); check(w_in_B(wd, Bh)) % -> PASS
#+end_src
A lag recursive method for computing a /minimal/ kernel representation of $\mathcal{B}_\text{mpum}({w_\text{d}})$ is implemented in the function =mpum=:
#+begin_src matlab :tangle demo.m
R_ = mpum(wd); check(w_in_B(wd, R2BT(R_, q, Td))) % -> PASS
#+end_src

=c_mpum=, =w2R=, =w2ss=, and =mpum= use the same methods as =BT2c=, =BT2R=, =BT2ss=, and =BT2Rmin=, respectively. \danger The former operate on $B_T$ while the latter on $\mathcal{H}_T({w_\text{d}})$. For exact data satisfying the GPE condition, $\text{image}\,B_T=\text{image}\,\mathcal{H}_T({w_\text{d}})$ and the functions yield the same result. For inexact data, an approximation of $\text{image}\,\mathcal{H}_{T_{text{d}}}({w_\text{d}})$ by a low-dimensional linear time-invariant structured subspace is needed. This is a nontrivial operation that makes system identification problems harder than corresponding analysis problems.

* preamble								 :NP:
#+AUTHOR: Ivan Markovsky
#+DATE:  
#+CREATOR: Ivan Markovsky 
#+OPTIONS:     num:nil toc:nil html-postamble:nil
#+LaTeX_CLASS_OPTIONS: [11pt,a4paper]
#+LaTeX_HEADER: \input{/home/im/texinputs/mystyle-org.tex}\usepackage[final]{pdfpages}
# #+LaTeX_HEADER: \usepackage[backend=biber]{biblatex}\bibliography{bib-new,bib,mypapers}
#+LaTeX_HEADER: \newcommand{\quotebib}[1]{\begin{quote}\small\bibentry{#1}\end{quote}}
#+LaTeX_HEADER: \topmargin=-1.5cm  \oddsidemargin=-1cm \evensidemargin=-1cm 
#+LaTeX_HEADER: \textheight=25cm   \textwidth=18cm
#+EXCLUDE_TAGS: NP SOL
#+SELECT_TAGS: 
#+DESCRIPTION:
##+INFOJS_OPT: view:info toc:nil ltoc:t

