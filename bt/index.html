<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-12-17 Wed 08:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Behavioral Toolbox</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Ivan Markovsky" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">The Behavioral Toolbox</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbecc231">Summary and downloads</a></li>
<li><a href="#org554e92c">Tutorial</a>
<ul>
<li><a href="#org2e2e88e">Nonparameteric representation of the restricted behavior</a></li>
<li><a href="#org3372350">Input/output partitionings</a></li>
<li><a href="#org60869d1">Subbehaviors</a></li>
<li><a href="#orgf000f99">Analysis</a>
<ul>
<li><a href="#orga181983">System&rsquo;s complexity</a></li>
<li><a href="#orgf7f70dc">Distance between systems</a></li>
<li><a href="#org28c5b3a">Controllability</a></li>
<li><a href="#orgf2fba00">\(H_\infty\)-norm</a></li>
</ul>
</li>
<li><a href="#org50d9cd6">Parametric representations</a></li>
<li><a href="#org4e595aa">Signal processing and open-loop control</a>
<ul>
<li><a href="#org79e5e12">Projection</a></li>
<li><a href="#org8518726">Initial conditions estimation</a></li>
<li><a href="#org300bc71">Simulation</a></li>
<li><a href="#orga7f2be6">Observer</a></li>
<li><a href="#org56db867">Open-loop control</a></li>
<li><a href="#org9c0fa77">Control as interconnection</a></li>
</ul>
</li>
<li><a href="#org876197d">Identification</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgbecc231" class="outline-2">
<h2 id="orgbecc231">Summary and downloads</h2>
<div class="outline-text-2" id="text-orgbecc231">
<p>
The Behavioral Toolbox is a collection of Matlab functions for analysis and design of dynamical systems using the behavioral approach to systems theory and control. It implements newly emerged nonparameteric data-driven methods for linear time-invariant systems.
</p>
<ul class="org-ul">
<li><a href="./bt.tar">tar file of the functions</a></li>
<li><a href="./bt.pdf">documentation</a></li>
<li><a href="https://imarkovs.github.io/publications/bt-l4dc.pdf">paper</a></li>
</ul>
</div>
</div>

<div id="outline-container-org554e92c" class="outline-2">
<h2 id="org554e92c">Tutorial</h2>
<div class="outline-text-2" id="text-org554e92c">
<p>
In order to make the behavioral approach computationally feasible, we consider discrete-time linear time-invariant systems over a finite horizon. The system&rsquo;s behavior in this case is a finite-dimensional shift-invariant subspace. The methods developed in the toolbox use a basis for this subspace as a nonparametric representation of the system. Analysis, signal processing, and control methods take as an input a basis. Identification methods take as an input a trajectory of the system and construct from it the nonparametric representation. 
</p>
</div>

<div id="outline-container-org2e2e88e" class="outline-3">
<h3 id="org2e2e88e">Nonparameteric representation of the restricted behavior</h3>
<div class="outline-text-3" id="text-org2e2e88e">
<p>
This section introduces the functions of the toolbox for creating and using the nonparametric representation of the system. As an illustrating numerical examples, we create a random linear time-invariant system defined by an input/state/output representation&#x2014;a Matlab&rsquo;s <code>ss</code> object <code>B</code>:  
</p>
<div class="org-src-container">
<pre class="src src-matlab">m = 2; p = 1; q = m <span style="color: #98fb98;">+</span> p; n = 3; B = drss(n, p, m);
</pre>
</div>
<p>
After choosing a horizon <code>T</code>, the construction of an orthonormal basis <code>BT</code> for the finite-horizon behavior from the input/state/output representation <code>B</code> of the system is done by the function <code>B2BT</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">T = 10; BT = B2BT(B, T); 
</pre>
</div>

<p>
The function <code>B2BT</code> implements a data-driven approach. Instead of using the parameters of the state-space representation of the system, it computes a random trajectory (using <code>lsim</code>), forms a Hankel matrix (using the toolbox&rsquo;s function <code>hank</code>), and computes an orthonormal basis for its image (using the <code>svd</code>). Alternative functions to <code>B2BT</code> that implement the model-based approach are <code>ss2BT</code> and <code>R2BT</code>. As the names suggest, <code>ss2BT</code> uses a state-space representation, while <code>R2BT</code> uses a kernel representation to compute the basis.
</p>

<p>
In order to verify that the output <code>BT</code> of <code>B2BT</code> is correct, first, we verify that its dimension is correct:
</p>
<div class="org-src-container">
<pre class="src src-matlab">check(size(BT, 2) <span style="color: #98fb98;">==</span> m <span style="color: #98fb98;">*</span> T <span style="color: #98fb98;">+</span> n) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
The function <code>check</code> prints &ldquo;PASS&rdquo; if its argument is true and &ldquo;FAIL&rdquo; otherwise. 
</p>

<p>
Then, we check that a random trajectory of the system is in the image of <code>BT</code>. The function <code>B2w</code> selects a random trajectory of <code>B</code>. Its output is a \(T\times q\) matrix, where \(T\) is the number of samples and \(q\) is the number of variables. Checking if \(w\) is a trajectory is a common task and is implemented in a function <code>w_in_B</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">w = B2w(B, T); check(w_in_B(w, B)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
The columns of <code>BT</code> are finite trajectories of the system. The function <code>BT2W</code> extracts them into a cell array <code>W</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">W = BT2W(BT, q); check(all(w_in_B(W, B))) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
The function <code>w_in_B</code> as well as many other functions of the toolbox allow specification of multiple trajectories by a cell array as well as a single trajectory.
</p>

<p>
A \(q\)-variate, \(T\)-samples long signal \(w := \big(w(1),\ldots,w(T)\big)\) is represented in the toolbox by: 
</p>
<ul class="org-ul">
<li>\(T\times q\) matrix <code>w</code>, where <code>w(t, :)</code> \(= w^\top(t)\) or</li>
<li>\(qT\times 1\) vector <code>w</code> with the stacked consecutive samples.</li>
</ul>
<p>
The matrix format has the advantage that the number of variables \(q\) can be deduced from the size. However, it is incompatible with the data-driven representation, which uses the vector format. The conversion from the matrix to the vector format is done by <code>vec(w')</code>, where <code>vec</code> is column-wise vectorization, and the conversion from the vector to the matrix format is done by <code>reshape(w, q, T)'</code>. Functions accepting \(B_T\) as an input require \(q\) to be passed as an extra input argument.
</p>

<p>
When the \(T\times q\) matrix representation is used, multiple trajectories are stored in a cell array with \(N\) elements, the \(i\)th element of which is a \(T_i\times q\) matrix representing the \(i\)th trajectory \(w^i\).  
When the \(Tq\times1\) vector representation is used and \(T_1=\cdots=T_N=:T\), multiple trajectories are stored in a \(qT\times N\) matrix, the \(i\)th column of which represents the \(i\)th trajectory \(w^i\).  
</p>

<p>
The computation of a basis \(B_T\) from a trajectory of the system requires finding the dimension of of the finite-horizon behavior \(\mathcal{B}|_T\). \danger Under standard conditions on \({w_\text{d}}\) that are almost certainly satisfied for a sufficiently long random trajectory \({w_\text{d}}\in\mathcal{B}|_T\), 
\[
\dim\,\mathcal{B}|_T = \text{rank}\,\mathcal{H}_T({w_\text{d}}). 
\]
Thus, \(\dim\,\mathcal{B}|_T\) can be found by rank computation. A robust way of computing \(\text{rank}\,\mathcal{H}_T({w_\text{d}})\) is thresholding the singular values of \(\mathcal{H}_T({w_\text{d}})\). The functions of the toolbox that construct \(B_T\) from data therefore have an optional threshold parameter <code>tol</code> with default value:
</p>
<div class="org-src-container">
<pre class="src src-matlab" id="org98f4cff"><span style="color: #00ffff;">if</span> <span style="color: #98fb98;">~</span>exist(<span style="color: #ff7f24;">'tol'</span>, <span style="color: #ff7f24;">'var'</span>) <span style="color: #98fb98;">||</span> isempty(tol), tol = 1e<span style="color: #98fb98;">-</span>8; <span style="color: #00ffff;">end</span> <span style="color: #ee0000;">% &lt;default-tol&gt;</span>
</pre>
</div>
<p>
Alternatively, the user can specify the model&rsquo;s complexity, in which case the dimension is computed as \(mT+n\).
</p>
</div>
</div>

<div id="outline-container-org3372350" class="outline-3">
<h3 id="org3372350">Input/output partitionings</h3>
<div class="outline-text-3" id="text-org3372350">
<p>
A partitioning of the variables \(w(t)\) into inputs \(u(t)\) and outputs \(y(t)\) is defined by a permutation matrix \(\Pi\in\mathbb{R}^{q\times q}\) as follows:
\[
w\mapsto(u,y): \ \begin{bmatrix} u\\y\end{bmatrix} := \Pi w \qquad\text{and}\qquad (u,y)\mapsto w: \ w = \Pi^\top \begin{bmatrix} u\\y\end{bmatrix}. 
\]
\(\Pi w\) reorders the variables \(w\), so that the first \(m\) variables are the inputs and the remaining \(p:=q-m\) variables are the outputs. The permutation matrix \(\Pi\) is specified in the functions of the toolbox by a vector <code>io</code>, such that <code>w(io)</code> \(\mapsto\) <code>[u; y]</code>. The restricted behavior with permuted variables is created with the function <code>BT2BT</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">io = flip(1<span style="color: #98fb98;">:</span>q); BTp = BT2BT(BT, q, io);
</pre>
</div>
<p>
Indeed, the trajectory \(w':=\Pi w\) with permuted variables belongs to the image of <code>BTp</code>: 
</p>
<div class="org-src-container">
<pre class="src src-matlab">check(w_in_B(w(<span style="color: #98fb98;">:</span>, io), BTp)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
The function <code>BT2UYT</code> extracts from the basis of the restricted behavior \(\mathcal{B}|_T\) its input and output components:
</p>
<div class="org-src-container">
<pre class="src src-matlab">[UT, YT] = BT2UYT(BT, m, p);
</pre>
</div>

<p>
<code>BT2UYT</code> and other functions of the toolbox that require an input/output partitioning but do not accept a specification for it assume \(\Pi = I_q\):
</p>
<div class="org-src-container">
<pre class="src src-matlab" id="org23a5f56"><span style="color: #00ffff;">if</span> <span style="color: #98fb98;">~</span>exist(<span style="color: #ff7f24;">'io'</span>, <span style="color: #ff7f24;">'var'</span>) <span style="color: #98fb98;">||</span> isempty(io), io = 1<span style="color: #98fb98;">:</span>q; <span style="color: #00ffff;">end</span> <span style="color: #ee0000;">% &lt;default-io&gt;</span>
</pre>
</div>
<p>
For a general input/output partitioning, defined by <code>io</code>, call the functions with input <code>BT2BT(BT, q, io)</code> instead of <code>BT</code>.
</p>

<p>
The inverse transformation <code>UYT2BT</code> reconstructs \(\mathcal{B}|_T\) from its input and output components:
</p>
<div class="org-src-container">
<pre class="src src-matlab">check(norm(BT <span style="color: #98fb98;">-</span> UYT2BT(UT, YT, m, p)) <span style="color: #98fb98;">==</span> 0) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>

<p>
The number of inputs \(m\) is uniquely defined by the behavior. However, an input/output partitioning of the variables is in general not unique. The currently available methods in the literature for finding an input/output partitioning of a system \(\mathcal{B}\) are based on parametric representations of the system (e.g., the kernel representation). The toolbox implements a data-driven method for finding an input/output partitioning directly from the finite-horizon behavior \(\mathcal{B}|_T\). The function <code>is_io</code> checks if a given partitioning of the variables is a possible input/output partitioning and the function <code>BT2IO</code> finds all possible input/output partitionings of the system. In order to test <code>is_io</code> and <code>BT2IO</code>, consider the following single-input single-output system 
</p>
<div class="org-src-container">
<pre class="src src-matlab">Bp = ss(tf([0 1], [1 1], 1));
</pre>
</div>
<p>
that has an input/output partitioning \(w = \left[\begin{smallmatrix} u\\y \end{smallmatrix}\right]\) but not \(w = \left[\begin{smallmatrix} y\\u \end{smallmatrix}\right]\).
</p>
<div class="org-src-container">
<pre class="src src-matlab">BpT = B2BT(Bp, T);
check(is_io(BpT, 2, [1 2]) <span style="color: #98fb98;">==</span> true)  <span style="color: #ee0000;">% -&gt; PASS </span>
check(is_io(BpT, 2, [2 1]) <span style="color: #98fb98;">==</span> false) <span style="color: #ee0000;">% -&gt; PASS</span>
check(all(BT2IO(BpT, 2) <span style="color: #98fb98;">==</span> [1 2]))   <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org60869d1" class="outline-3">
<h3 id="org60869d1">Subbehaviors</h3>
<div class="outline-text-3" id="text-org60869d1">
<p>
The following subbehaviors of \(\mathcal{B}\) are of special interest:
</p>
<ul class="org-ul">
<li>\(\mathcal{Y}_0\) &#x2014; <i>zero-input subbehavior</i>, i.e., the set of transient responses,</li>
<li>\(\mathcal{U}_0\) &#x2014; <i>zero-output subbehavior</i>, i.e., the set of inputs blocked by the system,</li>
<li>\(\mathcal{B}_0\)          &#x2014; <i>zero initial conditions subbehavior</i>, i.e., the set of zero initial conditions trajectories,</li>
<li>\(\mathcal{B}_\text{c}\)   &#x2014; <i>controllable subbehavior</i>, i.e., the set of trajectories that are patchable with zero past trajectory, and</li>
<li>\(\mathcal{B}_\text{p}\)   &#x2014; <i>periodic subbehavior</i>, i.e., the set of periodic trajectories.</li>
</ul>
<p>
Orthonormal bases for their restrictions to \([1,T]\) are computed from \(\mathcal{B}|_T\) by the following functions:
</p>
<div class="org-src-container">
<pre class="src src-matlab">Y0 = BT2Y0(BT, q);
U0 = BT2U0(BT, q);
B0 = BT2B0(BT, q);
BC = BT2BC(BT, q);
</pre>
</div>

<p>
Let&rsquo;s verify that a free response of \(\mathcal{B}\) is in the image of <code>Y0</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">y0 = initial(B, rand(n, 1), T<span style="color: #98fb98;">-</span>1); check(w_in_B(y0, Y0)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
Next, we verify that \(w = \left[\begin{smallmatrix} u\\ 0 \end{smallmatrix}\right]\) with \(u\) in the image of <code>U0</code> is a trajectory of the system:
</p>
<div class="org-src-container">
<pre class="src src-matlab">u0 = reshape(U0 <span style="color: #98fb98;">*</span> rand(size(U0, 2), 1), m, T)';
w0 = [u0 zeros(T, p)]; check(w_in_B(w0, BT)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
Next, we verify that the initial conditions of a random trajectory in the zero initial conditions subbehavior are zero
</p>
<div class="org-src-container">
<pre class="src src-matlab">T0 = size(B0, 1) <span style="color: #98fb98;">/</span> q;
w0 = reshape(B0 <span style="color: #98fb98;">*</span> rand(size(B0, 2), 1), q, T0)'; 
xini = w2xini(w0, B); check(norm(xini) <span style="color: #98fb98;">&lt;</span> tol) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>

<p>
Using the zero initial conditions subbehavior \(\mathcal{B}_0\subset\mathcal{B}|_T\), we can find the zero initial conditions input-to-output map \(H_T : u|_T \mapsto y|_T\). Let \(B_0\) be the matrix of the basis vectors for \(\mathcal{B}_0\) and let \(U_0\), \(Y_0\) be the submatrices of \(B_0\) corresponding to the inputs and the outputs. Then, \(H_T = Y_0 U_0^{-1}\). The method is implemented in the function <code>BT2HT</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">[HT, T] = BT2HT(BT, q);
</pre>
</div>
<p>
The \(pT\times mT\) matrix \(H_T\) is the finite-horizon representation of the transfer function \(H(z)\) of the system \(\mathcal{B}\) corresponding to the input/output partitioning. In particular, it has lower-triangular block-Toeplitz structure:
</p>
<div class="org-src-container">
<pre class="src src-matlab">check(norm(HT <span style="color: #98fb98;">-</span> convm(B, T)) <span style="color: #98fb98;">&lt;</span> tol) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf000f99" class="outline-3">
<h3 id="orgf000f99">Analysis</h3>
<div class="outline-text-3" id="text-orgf000f99">
<p>
In this section, we find properties of the system directly from its restricted behavior, rather than from parametric representations as done by classical analysis methods. The properties considered are: complexity, controllability, \(H_\infty\)-norm, and distance between systems. 
</p>
</div>

<div id="outline-container-orga181983" class="outline-4">
<h4 id="orga181983">System&rsquo;s complexity</h4>
<div class="outline-text-4" id="text-orga181983">
<p>
The complexity \(\mathbf{c}(\mathcal{B})\) of a linear time-invariant system \(\mathcal{B}\) is defined as the triple: number of inputs \(\mathbf{m}(\mathcal{B})\), lag \(\mathbf{\ell}(\mathcal{B})\), and order \(\mathbf{n}(\mathcal{B})\). Although in the classical setting the order \(\mathbf{n}(\mathcal{B})\) is defined via a minimal state-space representation, it is a property of the system \(\mathcal{B}\) and can be computed directly from the restricted behavior \(\mathcal{B}|_T\) (provided \(T\geq\mathbf{\ell}(\mathcal{B})+1\)). Also, the number of inputs \(\mathbf{m}(\mathcal{B})\) can be computed from \(\mathcal{B}|_T\) without reference to a particular input/output representation. The method for finding \(\mathbf{m}(\mathcal{B})\) and \(\mathbf{n}(\mathcal{B})\) from \(\mathcal{B}|_T\) is based on the theoretical dimension \(mT+n\). Evaluating \(\dim\,\mathcal{B}|_{t_i}\) for \(t_1\neq t_2\geq\mathbf{\ell}(\mathcal{B})\), e.g., \(t_1=T\) and \(t_2=T-1\), we obtain the system of equations
\[\begin{bmatrix} T & 1\\ T-1 & 1 \end{bmatrix} \begin{bmatrix} m\\ n \end{bmatrix} = \begin{bmatrix} \dim\,\mathcal{B}|_T\\ \dim\,\mathcal{B}|_{T-1} \end{bmatrix},\]
from which \(m=\mathbf{m}(\mathcal{B})\) and \(n=\mathbf{n}(\mathcal{B})\) can be found. The resulting method is implemented in the function <code>BT2c</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">[ch, mh, ellh, nh] = BT2c(BT, q); check(all([mh nh] <span style="color: #98fb98;">==</span> [m n])) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
A model-based method for computing the lag of the system is implemented in the function <code>lag</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">ell = lag(B); check(ellh <span style="color: #98fb98;">==</span> ell) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
As discussed in the next section, the complexity connects nonparameteric and parametric representations and is a critical first step in finding a parametric representation of the system. 
</p>

<p>
<code>BT2c</code> finds \(\dim\,\mathcal{B}|_{T-1}\) and \(\dim\,\mathcal{B}|_{T}\) by rank computation, i.e., thresholding of the singular values using \danger a user defined threshold <code>tol</code>. 
</p>
</div>
</div>

<div id="outline-container-orgf7f70dc" class="outline-4">
<h4 id="orgf7f70dc">Distance between systems</h4>
<div class="outline-text-4" id="text-orgf7f70dc">
<p>
The function <code>Bdist</code> computes distance between systems. The distance is defined as the principal angle between the finite-horizon behaviors of the systems with default horizon \(T=100\). Here is an example:
</p>
<div class="org-src-container">
<pre class="src src-matlab">Bp = B; Bp.a = Bp.a <span style="color: #98fb98;">+</span> 0.01 <span style="color: #98fb98;">*</span> randn(n); d = Bdist(B, Bp);
</pre>
</div>
<p>
The distance measure <code>Bdist</code> is used by the function <code>equal</code> for checking if two systems are equal:
</p>
<div class="org-src-container">
<pre class="src src-matlab">Bp = ss2ss(B, rand(n)); check(equal(B, Bp)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org28c5b3a" class="outline-4">
<h4 id="org28c5b3a">Controllability</h4>
<div class="outline-text-4" id="text-org28c5b3a">
<p>
The controllable subbehavior \(\mathcal{B}_c\subset\mathcal{B}|_T\) for \(T\geq\mathbf{\ell}(\mathcal{B})\) is \(mT+n\)-dimensional if and only if \(\mathcal{B}\) is controllable. This leads to a data-driven controllability test that is implemented in the function <code>isunctr</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">Bp = ss([0.5 1; 0 0.25], [1; 0], [1 1], 1, <span style="color: #98fb98;">-</span>1); 
n_unctr = isunctr(Bp); check(n_unctr <span style="color: #98fb98;">==</span> 1)  <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
Moreover, \(mT + n - \dim\,\mathcal{B}_c|_T\) is the number of uncontrollable modes of \(\mathcal{B}\). Based on \(\mathcal{B}_c\), a quantitative test for controllability&#x2014;a distance to uncontrollability&#x2014;is implemented in the function <code>distunctr</code>. Here is an example:
</p>
<div class="org-src-container">
<pre class="src src-matlab">Bp = ss([0.5 1; 0 0.25], [1; 1e<span style="color: #98fb98;">-</span>5], [1 1], 1, <span style="color: #98fb98;">-</span>1); 
d = distunctr(Bp); <span style="color: #ee0000;">% -&gt; 1e-7</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf2fba00" class="outline-4">
<h4 id="orgf2fba00">\(H_\infty\)-norm</h4>
<div class="outline-text-4" id="text-orgf2fba00">
<p>
Using the zero initial conditions input-to-output map \(H_T\) of \(\mathcal{B}\) for a given input/output partitioning allows us to compute the finite-horizon \(H_\infty\)-norm of \(\mathcal{B}\). The method is implemented in the function <code>BT2Hinf</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">[Hinf, <span style="color: #98fb98;">~</span>, uinf] = BT2Hinf(BT, q); C = convm(B, T);
check(abs(Hinf <span style="color: #98fb98;">-</span> norm(C)) <span style="color: #98fb98;">/</span> norm(C) <span style="color: #98fb98;">&lt;</span> tol) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org50d9cd6" class="outline-3">
<h3 id="org50d9cd6">Parametric representations</h3>
<div class="outline-text-3" id="text-org50d9cd6">
<p>
So far, the tutorial reviewed functions related to and based on the nonparametric representation of the restricted behavior \(\mathcal{B}|_T\). This section shows an application of the approach for computing parametric representations.
</p>

<p>
Computing a kernel representation from \(\mathcal{B}|_T\) is essentially applying the <code>null</code> function on \(B^\top_{\ell+1}\). The method is implemented in the functions <code>B2R</code> and <code>BT2R</code> (<code>B2R</code> constructs <code>BT</code> from <code>B</code> and calls <code>BT2R</code>):
</p>
<div class="org-src-container">
<pre class="src src-matlab">R = B2R(B); R = BT2R(BT, q); 
</pre>
</div>
<p>
The inverse operation&#x2014;finding the restricted behavior from a kernel or a state-space representation&#x2014;is done by the functions <code>R2BT</code> and <code>ss2BT</code>, which implement the model-based approach, i.e., they construct \(B_T\) from the model parameters \(R\) and \((A,B,C,D)\), respectively. 
</p>
<div class="org-src-container">
<pre class="src src-matlab">BT_ = R2BT(B2R(B), q, T); check(equal(B, BT_)) <span style="color: #ee0000;">% -&gt; PASS</span>
BT_ = ss2BT(B, T);        check(equal(B, BT_)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
The basis computed by <code>ss2BT</code> is not orthonormal. It consists of observability and convolution matrices.
</p>

<p>
Contrary to <code>BT2R</code> (which is essentially Matlab&rsquo;s <code>null</code> function), computing a state-space representation from the restricted behavior is nontrivial. Indeed, it requires to do 1) state construction and 2) detect a possible input/output partitioning of the variables. The data-driven approach for these operations is implemented in the function <code>BT2ss</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">check(equal(B, BT2ss(BT, q))) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
Similarly, the transformation from a kernel representation to a state-space representation is nontrivial. A data-driven method for this operation is implemented in the function <code>R2ss</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">check(equal(B, R2ss(R, q))) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>

<p>
For multi-output systems, the function <code>B2R</code> computes a <i>nonminimal</i> kernel representation. Computing a minimal kernel representation or converting a nonminimal kernel representation to a minimal one are also nontrivial operations. Data-driven methods for them are implemented in the functions <code>BT2Rmin</code> and <code>R2Rmin</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">Rmin = BT2Rmin(BT, q); check(equal(BT, R2BT(Rmin, q, T), q)) <span style="color: #ee0000;">% -&gt; PASS</span>
Rmin = R2Rmin(R, q);   check(equal(BT, R2BT(Rmin, q, T), q)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>

<p>
The dichotomy of parametric vs nonparametric representations is misleading&#x2014;there is a range of nonminimal parametric representations that cover the gap between minimal parametric and nonparametric representations. The problem of detecting when a parametric representation is minimal is equivalent to the one of finding the model&rsquo;s complexity. It is also essential in the case of identification from noisy data where the key issue is the one of achieving an accuracy&#x2013;complexity trade-off.
</p>

<p>
All functions of the toolbox computing model&rsquo;s complexity accept as an optional input argument a tolerance for thresholding the singular values. Alternatively, the user may specify the model&rsquo;s complexity <code>[m, ell, n]</code> by <code>ctol</code>. If <code>ctol</code> is a scalar, it is used as a threshold <code>tol</code> for rank estimation. Otherwise, <code>ctol</code> should be the vector of integers specifying the model&rsquo;s complexity. 
</p>
</div>
</div>

<div id="outline-container-org4e595aa" class="outline-3">
<h3 id="org4e595aa">Signal processing and open-loop control</h3>
<div class="outline-text-3" id="text-org4e595aa">
<p>
This section collects operations on signals by a dynamical system. The operations implemented are: projection of a signal on a system, computing initial conditions for a signal, simulation, and inference of one variable from another. They are special cases of a signal processing problem, called <i>interpolation and approximation of trajectories</i>.
</p>
</div>

<div id="outline-container-org79e5e12" class="outline-4">
<h4 id="org79e5e12">Projection</h4>
<div class="outline-text-4" id="text-org79e5e12">
<p>
The basic operation of projection of a signal \(w\in(\mathbb{R}^q)^T\) on the behavior \(\mathcal{B}|_T\) of a system \(\mathcal{B}\in\mathcal{L}^q\) is equivalent to computing the <i>distance from \(w\) to \(\mathcal{B}\)</i>. The same operation is equivalent to (errors-in-variables) Kalman smoothing: the projection \(\hat w\) is the <i>smoothed version</i> of \(w\). The problem is solved by the function <code>dist</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">[d, wh] = dist(w, B);
</pre>
</div>
<p>
The distance <code>d</code> from \(w\) to \(\mathcal{B}|_T\) is zero if and only if \(w\in\mathcal{B}|_T\), so that <code>dist</code> is a robust way of checking if \(w\) is an exact trajectory of \(\mathcal{B}\). (It is used in the implementation of <code>w_in_B</code>.) 
</p>
</div>
</div>

<div id="outline-container-org8518726" class="outline-4">
<h4 id="org8518726">Initial conditions estimation</h4>
<div class="outline-text-4" id="text-org8518726">
<p>
For \({w_\text{d}}\in\mathcal{B}|_T\), there is a corresponding initial conditions. 
If \(\mathcal{B}\) is defined by an input/state/output representation, the initial conditions can be specified by the initial state \(x_\text{ini} = x(1)\). The initial state \(x_\text{ini}\) corresponding to a trajectory \(w\) can be found with the function <code>w2xini</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">[xini, e] = w2xini(w, B); check(norm(w <span style="color: #98fb98;">-</span> B2w(B, T, xini, w(<span style="color: #98fb98;">:</span>, 1<span style="color: #98fb98;">:</span>m))) <span style="color: #98fb98;">&lt;</span> tol)  <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
The output argument <code>e</code> is zero when \(w\in\mathcal{B}|_T\) and nonzero otherwise.
</p>

<p>
The initial conditions can be specified in a representation free way by an initial trajectory \(w_\text{ini}\) of length \(T_{\text{ini}}\geq\mathbf{\ell}(\mathcal{B})\). An initial trajectory \(w_\text{ini}\) of corresponding to a given trajectory \(w\) can be computed by the function <code>w2wini</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">BT = B2BT(B, ell <span style="color: #98fb98;">+</span> size(w,1));
[wini, e] = w2wini(w, BT, ell); check(w_in_B([wini; w], B)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org300bc71" class="outline-4">
<h4 id="org300bc71">Simulation</h4>
<div class="outline-text-4" id="text-org300bc71">
<p>
The classical simulation problem: given initial conditions and input, find the corresponding output is solved by <code>u2y</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">yf = u2y(BT, q, w(<span style="color: #98fb98;">:</span>, 1<span style="color: #98fb98;">:</span>m), wini); check(w(<span style="color: #98fb98;">:</span>, m<span style="color: #98fb98;">+</span>1<span style="color: #98fb98;">:</span>end) <span style="color: #98fb98;">-</span> yf) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>

<p>
As another example, next, we use <code>u2y</code> in order to find the first <code>Tf</code> samples of the impulse response of the system:
</p>
<div class="org-src-container">
<pre class="src src-matlab">Tf = 3; u1 = [[1; zeros(q <span style="color: #98fb98;">*</span> Tf <span style="color: #98fb98;">-</span> 1, 1)] zeros(q <span style="color: #98fb98;">*</span> Tf, m <span style="color: #98fb98;">-</span> 1)];
h1 = u2y(BT, q, u1); h = lsim(B, u1); check(h1 <span style="color: #98fb98;">-</span> h <span style="color: #98fb98;">&lt;</span> tol) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga7f2be6" class="outline-4">
<h4 id="orga7f2be6">Observer</h4>
<div class="outline-text-4" id="text-orga7f2be6">
<p>
Consider a linear time-invariant system \(\mathcal{B}\in\mathcal{L}^q\). The variables \(w\) of \(\mathcal{B}\) are partitioned into given/observed variables \(w_{\text{g}}\) with dimension \(q_{\text{g}}\) and missing/to-be-estimated variables \(w_{\text{m}}\) with dimension \(q_{\text{m}} = q - q_{\text{g}}\). Without loss of generality, we assume that \(w = \left[\begin{smallmatrix} w_{\text{g}}\\ w_m \end{smallmatrix}\right]\). The problem considered is: Given a system \(\mathcal{B}\in\mathcal{L}^q\) and observed part \(w_{\text{g}}\) of a trajectory \(w\in\mathcal{B}|_T\), find the missing part \(w_{\text{m}}\) of \(w\).
</p>

<p>
The solution is based on the finite-horizon nonparameteric representation of \(\mathcal{B}\). Let \(B_{\text{g}}\) be the submatrix of \(B_T\) corresponding to \(w_{\text{g}}\) and \(B_{\text{m}}\) be the submatrix corresponding to \(w_{\text{m}}\). Then, there is a \(g\), such that 
\[w_{\text{g}} = B_{\text{g}} g \quad\text{and}\quad w_{\text{m}} = B_{\text{m}} g.\]
Solving for \(g\) the first equation and substituting into the second one, we have the following estimate of \(w_{\text{m}}\):
\[\hat w_{\text{m}} := B_{\text{m}} B_{\text{g}}^+ w_{\text{g}}.\]
It can be shown that, when \(\text{rank}\,B_{\text{g}} = \mathbf{m}(\mathcal{B})T+\mathbf{n}(\mathcal{B})\), \(\hat w_{\text{m}}\) is exact, i.e., of \(\hat w_{\text{m}}=w_{\text{m}}\). 
</p>

<p>
Special cases of the observer problem are estimation of the input given the output (which is also a system inversion problem) and estimation of a second input, e.g., disturbance, given the input and the output. 
</p>

<p>
The solution of the observer problem is implemented in the function <code>wgiven2wmissing</code>. Here is an example verifying the method for disturbance estimation:
</p>
<div class="org-src-container">
<pre class="src src-matlab">qg = 2; qm = 2; q = qm <span style="color: #98fb98;">+</span> qg; m = 1; p = q <span style="color: #98fb98;">-</span> m; n = 5; B = drss(n, p, m);
T = 20; w = B2w(B, T); wg = w(<span style="color: #98fb98;">:</span>, 1<span style="color: #98fb98;">:</span>qg); wm = w(<span style="color: #98fb98;">:</span>, qg<span style="color: #98fb98;">+</span>1<span style="color: #98fb98;">:</span>q);
wmh = wgiven2wmissing(wg, B); check(norm(wm <span style="color: #98fb98;">-</span> wmh) <span style="color: #98fb98;">/</span> norm(wm) <span style="color: #98fb98;">&lt;</span> tol) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org56db867" class="outline-4">
<h4 id="org56db867">Open-loop control</h4>
<div class="outline-text-4" id="text-org56db867">
<p>
The control problem considered is open-loop linear quadratic tracking: Given a system \(\mathcal{B}\in\mathcal{L}^q\), to-be-tracked trajectory \(w_\text{r}\in(\mathbb{R}^q)^{T_\text{r}}\), and tracking criterion 
\(\|e\|_v := \| v \otimes e \|,\)
where \(v\in(\mathbb{R}_+^q)^{T_\text{r}}\) and \(\otimes\) is the element product, 
\[
\text{minimize} \quad \text{over $\hat w\in(\mathbb{R}^q)^{T_\text{r}}$} \quad \text{norm}{w_\text{r} - \hat w}_v \quad\text{subject to}\quad \hat w \in \mathcal{B}|_{T_\text{r}}.
\]
</p>

<p>
A variation of the problem is to specify initial and final conditions for the control trajectory \(\hat w\) via &ldquo;past&rdquo; and &ldquo;future&rdquo; trajectories \(w_{\text{p}}\in(\mathbb{R}^q)^{T_{\text{p}}}\) and \(w_\text{f}\in(\mathbb{R}^q)^{T_\text{f}}\):
\[
\text{minimize} \quad \text{over $\hat w\in(\mathbb{R}^q)^{T_\text{r}}$} \quad \text{norm}{w_\text{r} - \hat w}_v 
\quad\text{subject to}\quad 
w_{\text{p}} \wedge \hat w \wedge w_\text{f} \in \mathcal{B}|_{T_{\text{p}}+T_\text{r}+T_\text{f}}. 
\]
This allows us to solve optimal state transfer problems, i.e., find a trajectory of the system that achieves optimal transition from the given initial state to the given final state. The solution exists for any initial and final states if and only if the system \(\mathcal{B}\) is controllable and the state transfer is at least \(\mathbf{\ell}(\mathcal{B})\)-samples long.
</p>

<p>
The function in the toolbox solving the open-loop linear quadratic tracking control problem is 
</p>
<div class="org-src-container">
<pre class="src src-matlab">wh = lqctr(B, wr, v, wp, wf);
</pre>
</div>
<p>
The input parameters <code>v</code>, <code>wp</code>, and <code>wf</code> are optional. The default value of <code>v</code> is <code>ones(Tr, q)</code>, i.e., uniform weights for all variables and all moments of time. If <code>wp</code> and/or <code>wf</code> is not specified, then the corresponding constraints are dropped, i.e., the corresponding initial or final condition is free.
</p>

<p>
Here is an example of linear quadratic tracking with free initial and final condition:
</p>
<div class="org-src-container">
<pre class="src src-matlab">m = 1; p = 1; n = 3; q = m <span style="color: #98fb98;">+</span> p; B = drss(n, p, m); 
Tr = 10; wr = [zeros(Tr, m) ones(Tr, p)]; ell = lag(B);
v = [1e<span style="color: #98fb98;">-</span>2 <span style="color: #98fb98;">*</span> ones(Tr, m), ones(Tr, p)]; wh = lqctr(B, wr, v);
</pre>
</div>

<p>
In order to solve the optimal state transfer problem with specified initial and final states, first we check controllability of the system. The solution is verified by showing that \(w_{\text{p}}{w_\text{d}}edge \hat w{w_\text{d}}edge w_\text{f} \in \mathcal{B}|_{T_{\text{p}}+T_\text{r}+T_\text{f}}\).
</p>
<div class="org-src-container">
<pre class="src src-matlab"><span style="color: #00ffff;">if</span> <span style="color: #98fb98;">~</span>isunctr(B)
  Tr = ell; wr = zeros(Tr, q);
  wp = B2w(B, ell); wf = zeros(ell, q); 
  wh = lqctr(B, wr, [], wp, wf);
  check(w_in_B([wp; wh; wf], B))
<span style="color: #00ffff;">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9c0fa77" class="outline-4">
<h4 id="org9c0fa77">Control as interconnection</h4>
<div class="outline-text-4" id="text-org9c0fa77">
<p>
In the following example the plant \(\mathcal{B}\) is a \(4\)th order single-input single-output system, defined by the transfer function
\[H(z) =  \frac{0.2826z + 0.5067z^2}{1 - 1.4183z + 1.5894z^2 -1.3161z^3 + 0.8864z^4}.\]
</p>
<div class="org-src-container">
<pre class="src src-matlab">Q = [0 0 0 0.28261 0.50666]; P = [1 <span style="color: #98fb98;">-</span>1.41833 1.58939 <span style="color: #98fb98;">-</span>1.31608 0.88642];
B = ss(tf(Q, P, <span style="color: #98fb98;">-</span>1)); 
</pre>
</div>
<p>
The controller \(\mathcal{B}_\text{c}\) is obtained with the function <code>h2syn</code> from the Robust Control Toolbox of Matlab
</p>
<div class="org-src-container">
<pre class="src src-matlab">Bc = h2syn(B, 1, 1); 
</pre>
</div>
<p>
It leads to the closed-loop system \(\mathcal{B}_\text{cl}\)
</p>
<div class="org-src-container">
<pre class="src src-matlab">B_ = ss(B.a, B.b, [B.c; B.c], [B.d; B.d], 1); Bcl = lft(B_, Bc); 
</pre>
</div>

<p>
The closed-loop system \(\mathcal{B}_\text{cl}\) can be obtained alternatively by projecting on the \(y\)-variable the interconnection of the plant \(\mathcal{B}\) and the control \(\mathcal{B}_\text{c}\) with flipped inputs and outputs:
\[
\mathcal{B}_\text{cl} = \Pi_y \big( \mathcal{B} \cap \left[\begin{smallmatrix} 0&1\\ 1&0 \end{smallmatrix}\right] \mathcal{B}_\text{c} \big).
\]
</p>
<div class="org-src-container">
<pre class="src src-matlab">T = 10; BT = B2BT(B, T); BcT = B2BT(Bc, T); 
Bcl_wT = BTintersect(BT, BT2BT(BcT, q, [2 1])); 
[Bcl_uT, Bcl_yT] = BT2UYT(Bcl_wT, 1, 1); 
equal(Bcl, Bcl_yT, q) <span style="color: #ee0000;">% -&gt; 1</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org876197d" class="outline-3">
<h3 id="org876197d">Identification</h3>
<div class="outline-text-3" id="text-org876197d">
<p>
The functions presented in the previous sections of the tutorial use the nonparameteric representation of a linear time-invariant system \(\mathcal{B}\in\mathcal{L}_c^q\). In this section, the system \(\mathcal{B}\) is implicitly specified by a trajectory \(w_{\text{d}}\in\mathcal{B}|_{T_{text{d}}}\)
</p>
<div class="org-src-container">
<pre class="src src-matlab">Td = 100; wd = B2w(B, Td); 
</pre>
</div>
<p>
A necessary and sufficient condition for \({w_\text{d}}\) to define \(\mathcal{B}\in\mathcal{L}^q_c\) is the <i>identifiability condition</i>:
\]
\text{rank} \, \mathcal{H}<sub>\mathbf{\ell}(\mathcal{B})+1</sub>({w<sub>\text</sub>{d}}) = \mathbf{m}(\mathcal{B})\big(\mathbf{\ell}(\mathcal{B})+1\big) + \mathbf{n}(\mathcal{B}).
\]
This is a <i>generalized persistency of excitation</i> condition on the data \({w_\text{d}}\) and requires prior knowledge of the complexity \(\mathbf{c}(\mathcal{B})\) of the data-generating system \(\mathcal{B}\). 
</p>

<p>
When the GPE condition is satisfied, \(\mathcal{B}\) can be recovered from the data \({w_\text{d}}\). This is done by finding the <i>most powerful unfalsified model</i> \(\mathcal{B}_\text{mpum}({w_\text{d}})\) for \({w_\text{d}}\). \(\mathcal{B}_\text{mpum}({w_\text{d}})\) is the least complicated exact model for \({w_\text{d}}\) in the class of linear time-invariant systems \(\mathcal{L}^q\). Note that \(\mathcal{B}_\text{mpum}({w_\text{d}})\) is well defined (i.e., it exists and is unique) for any \({w_\text{d}}\in(\mathbb{R}^q)^T_{text{d}}\), independently of whether or not the GPE condition holds. Also, finding \(\mathcal{B}_\text{mpum}({w_\text{d}})\) from \({w_\text{d}}\) does not require priori knowledge of \(\mathbf{c}(\mathcal{B})\): \(\mathcal{B}_\text{mpum}({w_\text{d}})\) is a computational construct that has theoretical guarantees to recover the data-generating system under the GPE condition. 
</p>

<p>
For \(T\geq\mathbf{\ell}(\mathcal{B})\), under the stronger generalized persistency of excitation condition 
\]
\text{rank} \, \mathcal{H}<sub>T</sub>({w<sub>\text</sub>{d}}) = \mathbf{m}(\mathcal{B})T + \mathbf{n}(\mathcal{B}),
\]
the data-driven representation holds. A necessary condition for the GPE condition is that the length \(T_{\text{d}}\) of \({w_\text{d}}\) must satisfy the lower bound
\]
T<sub>\text{d}</sub> &ge; T<sub>min</sub> := (m+1)T+n-1,
\]
</p>
<div class="org-src-container">
<pre class="src src-matlab" id="org1be3136">Tmin = @(T) (m <span style="color: #98fb98;">+</span> 1) <span style="color: #98fb98;">*</span> T <span style="color: #98fb98;">+</span> n <span style="color: #98fb98;">-</span> 1; <span style="color: #ee0000;">%% &lt;define-Tmin&gt;</span>
</pre>
</div>
<p>
Thus, <code>Tmin</code> quantifies the statement &ldquo;\({w_\text{d}}\) is long enough for recovering the data-generating system&rdquo;.
</p>

<p>
An analog of <code>BT2c</code> for complexity computation from data \({w_\text{d}}\) is <code>c_mpum</code>, which computes \(\mathbf{c}\big(\mathcal{B}_\text{mpum}({w_\text{d}})\big)\) without explicitly identifying \(\mathcal{B}_\text{mpum}({w_\text{d}})\):
</p>
<div class="org-src-container">
<pre class="src src-matlab">ch = c_mpum(wd); check(all(ch <span style="color: #98fb98;">==</span> [m, lag(B), n])) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
The function <code>w2BT</code> computes a basis \(B_T\) for \(\mathcal{B}_\text{mpum}({w_\text{d}})|_T\) from data \({w_\text{d}}\) 
</p>
<div class="org-src-container">
<pre class="src src-matlab">BhT = w2BT(wd, T);
</pre>
</div>
<p>
Once \(\hat B_T\) is obtained from \({w_\text{d}}\), the non-parametric analysis functions from the previous sections can be used. 
</p>

<p>
The second parameter of <code>w2BT</code> allows specification of an upper bound <code>[m, ell, n]</code> on the model&rsquo;s complexity, in which case unstructured low-rank approximation is used to enforce the bound. Alternatively, the second parameter of <code>w2BT</code> can be a tolerance <code>tol</code> for the estimation of the complexity by singular values thresholding. Unlike the function <code>slra</code>, which imposes both rank and structure constraints, <code>w2BT</code> doesn&rsquo;t impose shift-invariance structure on <code>BT</code>.
</p>

<p>
<code>c_mpum</code> and <code>w2BT</code> detect, respectively, \(\mathbf{c}\big(\mathcal{B}_\text{mpum}({w_\text{d}})\big)\) and \(\dim\,\mathcal{B}_\text{mpum}({w_\text{d}})\) from the data \({w_\text{d}}\) by rank computation with a user defined tolerance. \danger Alternatively, the user may specify directly a complexity bound. When the complexity is wrongly estimated or misspecified, there may be no \(\hat{\mathcal{B}}\in\mathcal{L}^q_{(m,\ell,n)}\) that corresponds to \(\text{image}\, B_T\). 
</p>

<p>
The following functions compute parametric representations of \(\mathcal{B}_\text{mpum}({w_\text{d}})\) and thus by construction impose both the bounded complexity and LTI structure. A kernel representation of \(\mathcal{B}_\text{mpum}({w_\text{d}})\) is obtained by the function <code>w2R</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">R = w2R(wd); check(w_in_B(wd, R2BT(R, q, Td))) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
and a state-space representation by the function <code>w2ss</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">Bh = w2ss(wd); check(w_in_B(wd, Bh)) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>
<p>
A lag recursive method for computing a <i>minimal</i> kernel representation of \(\mathcal{B}_\text{mpum}({w_\text{d}})\) is implemented in the function <code>mpum</code>:
</p>
<div class="org-src-container">
<pre class="src src-matlab">R_ = mpum(wd); check(w_in_B(wd, R2BT(R_, q, Td))) <span style="color: #ee0000;">% -&gt; PASS</span>
</pre>
</div>

<p>
<code>c_mpum</code>, <code>w2R</code>, <code>w2ss</code>, and <code>mpum</code> use the same methods as <code>BT2c</code>, <code>BT2R</code>, <code>BT2ss</code>, and <code>BT2Rmin</code>, respectively. \danger The former operate on \(B_T\) while the latter on \(\mathcal{H}_T({w_\text{d}})\). For exact data satisfying the GPE condition, \(\text{image}\,B_T=\text{image}\,\mathcal{H}_T({w_\text{d}})\) and the functions yield the same result. For inexact data, an approximation of \(\text{image}\,\mathcal{H}_{T_{text{d}}}({w_\text{d}})\) by a low-dimensional linear time-invariant structured subspace is needed. This is a nontrivial operation that makes system identification problems harder than corresponding analysis problems.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
